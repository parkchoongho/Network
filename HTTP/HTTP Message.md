# HTTP 메시지

HTTP를 배달원이라 하면, HTTP 메시지는 무언가를 담아 보내는 소포와 같습니다.

### 3-1. 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고 받는 데이터의 블록들입니다. 이 데이터 블록들은 메시지 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 나타납니다. 이 메시지는 클라이언트, 서버, 프락시 사이를 흐르게 됩니다. '인바운드', '아웃바운드', '업스트림', '다운스트림'은 메시지의 방향을 의미하는 용어입니다.

### 3-1-1. 메시지는 원 서버 방향을 인바운드하여 송신

HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용합니다. 메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이라 하고, 모든 처리가 끝난 뒤 메시지가 사용자에게 돌아오는 것을 아웃바운드로 이동하는 것이라 합니다.

### 3-1-2. 다운 스트림으로 흐르는 메시지

HTTP 메시지는 강물처럼 흐릅니다. 요청, 응답메시지 모두 다운스트림으로 흐릅니다. 메시지의 발송자는 수신자의 업스트림입니다. 요청에서는 클라이언트가 서버의 업스트림이라면, 응답에서는 서버가 클라이언트의 업스트림이 됩니다. 

### 3-2. 메시지의 각 부분

메시지는 시작줄, 헤더 블록, 본문 이렇게 3가지로 나뉘어집니다. 시작줄은 이것이 어떤 메시지에 관한 것인지 알려주고, 헤더 블록은 속성, 본문은 데이터를 담고 있습니다. 경우에 따라, 본문은 없을 수도 있습니다. 시작줄과 헤더는 줄 단위로 분리된 아스키 문자열입니다. 각 줄은 캐리지 리턴과 개행 문자로 구성된 두 글자의 줄바꿈 문자열로 끝나게 됩니다. 이 줄바꿈 문자열을 'CRLF'라고 합니다. 메시지 본문은 단순한 데이터 덩어리입니다. 시작줄이나 헤더와는 달리, 본문은 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있습니다.

### 3-2-1. 메시지 문법

모든 HTTP 메시지는 요청과 응답으로 분류됩니다. 둘은 기본적으로 구조가 거의 같습니다. (시작줄이 조금 다릅니다.)

**메서드**

클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작을 의미합니다. 'GET', 'POST', 'HEAD'처럼 한 단어로 표현합니다. 

**요청 URL**

요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL 경로 구성요소입니다. 서버는 URL에서 생략된 호스트와 포트번호를 자신을 가리키는 것으로 간주합니다.

**버전**

메시지에서 사용중인 HTTP 버전입니다. 형식은 아래와 같습니다.

`HTTP/<메이저>.<마이너>`

메이저와 마이너는 모두 정수입니다.

**상태코드**

요청 중에 어떤일이 일어났는지 설명하는 세 자리 숫자입니다. 각 코드의 첫 번째 자릿수는 상태의 일반적인 분류(성공, 에러 등)를 나타냅니다.

**사유 구절(reason-phrase)**

숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 짧게 설명해주는 문구입니다. 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절입니다. 사유 구절은 오직 사람에게 읽히기 위한 목적으로 존재합니다.

**헤더**

이름, 콜론, 선택적 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들. 이 헤더의 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 본문의 시작을 표시합니다.

**엔터티 본문**

엔터티 본문은 임의의 데이터 블록을 포함합니다. 모든 메시지가 엔터티 본문을 가지는 것은 아니므로, 상황에 따라 메시지가 CRLF로 끝나기도 합니다. 

cf)  본문이 없을 경우 헤더 집합은 항상 빈줄로 끝나야하지만, 많은 클라이언트와 서버가 본문이 없는 경우 마지막 CRLF를 빠뜨리기도 합니다. 이렇게 규칙을 잘 지키지 않는 구현체와의 호환을 위해, 클라이언트와 서버는 마지막 CRLF 없이도 끝나는 메시지를 받을 수 있어야 합니다.

### 3-2-2. 시작줄

모든 HTTP 메시지는 시작줄로 시작하며 요청의 경우 무엇을 해야하는지 말해주고, 응답의 경우 무엇이 일어났는지 알려줍니다.

**요청줄**

요청 메시지 시작줄에는 어떤 동작이 일어나야 하는지 설명하는 메서드와 그 동작 대상을 지칭하는 요청URL이 포함됩니다. 또한 클라이언트가 어떤 HTTP 버전으로 요청하는지 서버가 알 수 있게하는 HTTP 버전까지 포함됩니다. 이 모든 영역은 공백으로 구분합니다. 

```http
GET /test/hi-there.txt HTTP/1.1
Accept: text/*
Host: www.joes-hardware.com
```

여기서 요청 메서드는 GET이고 요청 URL은 /test/hi-there.txt, 버전은 HTTP/1.1입니다.

**응답줄**

응답 메시지 시작줄에는 응답 메시지에 쓰인 HTTP 버전, 숫자 상태 코드, 수행 상태에 대한 설명 텍스트가 들어갑니다. 마찬가지로 모든 필드는 공백으로 구분됩니다.

```http
HTTP/1.0 200 OK
Content-type: text/plain
Content-length: 19

Hi! I'm a message!
```

위 메시지를 봅시다. HTTP 버전은 HTTP/1.0이고 상태 코드는 200, 사유구절은 OK로 문서가 성공적으로 반환되었음을 의미합니다.

**메서드**

HTTP 명세는 공통 요청 메서드 집합을 정의합니다. GET은 서버에서 문서를 가져오는 것이고, POST는 서버에서 처리했으면 하는 데이터를 보내는 것이고, OPTIONS 메서드는 웹 서버의 일반적인 지원 범위 혹은 웹 서버의 특정 리소스에 대한 지원 범위를 알아보는 것입니다.

| 메서드  | 설명                                                    | 메시지 본문 유무 |
| ------- | ------------------------------------------------------- | ---------------- |
| GET     | 서버에서 문서를 가져온다.                               | 무               |
| HEAD    | 서버에서 어떤 문서에 대한 헤더만 가져온다.              | 무               |
| POST    | 서버가 처리할 데이터를 보낸다.                          | 유               |
| PUT     | 서버에 요청 메시지의 본문을 저장한다.                   | 유               |
| TRACE   | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. | 무               |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다.         | 무               |
| DELETE  | 서버에서 문서를 제거한다.                               | 무               |

**상태 코드**

상태코드는 클라이언트에게 어떤일이 일어났는지 알려줍니다. 클라이언트의 요청은 항상 성공적이지 만은 않습니다. 요청한 리소스가 없거나, 리소스 접근권한이 없거나, 리소스가 다른 장소로 옮겨지는 등 여러가지 에러상황이 존재합니다. 이에 대해 어떻게 처리를 했는지 알려주는 것이 바로 상태 코드입니다. 

상태코드들은 세자리 숫자로 된 코드값을 기준으로 묶이게 됩니다. 

| 전체 범위 | 정의된 범위 | 분류            |
| --------- | ----------- | --------------- |
| 100-199   | 100-101     | 정보            |
| 200-299   | 200-206     | 성공            |
| 300-399   | 300-305     | 리다이렉션      |
| 400-499   | 400-415     | 클라이언트 에러 |
| 500-599   | 500-505     | 서버 에러       |

밑에는 만날 수 있는 가장 흔한 상태 코드를 표로 정리한 것입니다.

| 상태 코드 | 사유 구절    | 의미                                             |
| --------- | ------------ | ------------------------------------------------ |
| 200       | OK           | 성공! 요청한 모든 데이터가 응답 본문에 들어있다. |
| 401       | Unauthorized | 사용자 이름과 비밀번호를 입력해야 한다.          |
| 404       | Not Found    | 서버는 요청 URL에 대한 리소스를 찾지 못했다.     |

**사유 구절**

사유 구절은 응답 메시지의 마지막 구성요소입니다. 사유 구절은 상태 코드와 일대일로 대응됩니다. 사유 구절은 상태 코드의 사람이 이해하기 쉬운 버전입니다. HTTP 명세에는 사유 구절이 어떻게 되야 한다는 엄격한 규칙을 제공하지 않습니다.

**버전번호**

버전 번호는 HTTP/x.y의 형태로 요청 응답 모두에 기술됩니다. 이것은 HTTP 애플리케이션이 상대방에게 자신이 따르는 프로토콜 버전이 무엇인지 알려주기 위한 수단입니다. 버전 번호는 HTTP로 대화하는 애플리케이션에게 대화 상대의 능력과 메시지 형식에 대한 단서를 제공하기 위한 것으로 생각하시면 됩니다.

### 3-2-3. 헤더

시작줄 다음에는 0개, 1개 혹은 여러 개의 HTTP 헤더가 옵니다. HTTP 헤더 필드는 요청과 응답 메시지에 추가적인 정보를 더해줍니다. 기본적으로 이름/값 으로 구성된 목록입니다.

**일반 헤더**

요청과 응답 양쪽에 모두 나타날 수 있음

**요청 헤더**

요청에 대한 부가 정보를 제공

**응답 헤더**

응답에 대한 부가 정보를 제공

**Entity 헤더**

본문 크기와 리소스 그 자체를 서술

**확장 헤더**

명세에 정의되지 않은 헤더

각 HTTP 헤더는 문법을 가지고 있습니다. 이름, 쉼표, 공백(없어도 상관 무), 필드 값, CRLF가 순서대로 옵니다. 밑에는 흔히 쓰이는 헤더의 예시를 표로 정리한 것입니다.

| 헤더 예시                                | 설명                                                     |
| ---------------------------------------- | -------------------------------------------------------- |
| Date: Tue, 3OCT 1997 02:16:03 GMT        | 서버가 응답을 만들어낸 시각                              |
| Content-length: 15040                    | 15,040 바이트의 데이터를 포함한 엔터티 본문              |
| Content-type: image/gif                  | 엔터티 본문은 GIF 이미지                                 |
| Accept: image/gif, image/jpeg, text/html | 클라이언트는 GIF, JPEG 이미지와 HTML을 받아들일 수 있다. |

**헤더를 여러 줄로 나누기**

긴 헤더 줄은 여러 줄로 쪼개서 더 읽기 좋게 만들 수 있는데, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야합니다.

```http
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 8572
Server: Test Server
	Version 1.0

```

여기서 응답 메시지는 여러 줄로 쪼개진 Server 헤더를 포함하고 있습니다. 그 헤더의 완전한 값은 'Test Server Version 1.0'입니다.

### 3-2-4. 엔터티 본문

HTTP 메시지의 세 번째 부분은 선택적인 엔터티 본문입니다. 엔터티 본문은 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션 등 여러 종류의 디지털 데이터를 실어나를 수 있습니다. 

### 3-3. 메서드

모든 서버가 모든 메서드를 구현하지는 않습니다. HTTP 버전 1.1과 호환되고자 한다면, 서버는 자신의 리소스에 대해 GET과 HEAD 메서드만을 구현하는 것으로 충분합니다. 서버가 모든 메서드를 구현하지 않았어도 메서드는 대부분 제한적으로 사용될 것입니다. 예를 들어, DELETE와 PUT을  지원하는 서버는 아무나 저장된 리소스에 접근하여 삭제할 수 있게 하지는 않을 것입니다. 이 제한은 일반적으로 서버 설정에 의해 정해지고, 따라서 사이트마다 또 서버마다 다룰 수 있습니다.

### 3-3-1. 안전한 메서드(Safe Method)

HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의합니다. GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET이나 HEAD 메서드를 사용하는 HTTP 요청이 서버에 어떤 영향도 미치지 않음을 의미합니다. 영향을 미치지 않는다는 것은 요청 결과로 인해 서버에 어떤 변화가 없다는 것을 의미합니다.

안전한 메서드의 목적은, 서버에 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만드는 데 있습니다. 예를 들어, 쇼핑몰 사이트에서 웹 브라우저에서 안전하지 않은 메서드를 담는 요청이 만들어졌다면, 그 결과 서버에서 어떤 작용(신용카드가 결제되는 등)이 일어날 수 있음을 알려주는 경고 메시지를 띄울 것 입니다.

### 3-3-2. GET

GET은 가장 흔히 쓰이는 메서드입니다. 주로 서버에게 리소스를 달라고 요청하기 위해 사용됩니다. HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구하고 있습니다.

요청

```http
GET /seasonal/index-fall.html HTTP/1.1
Host: www.joes-hardware.com
Accept: *
```

응답

```http
HTTP/1.1 200 OK
Content-Type: text/html
Context-Length: 617

<HTML>
<HEAD>
.....
```

### 3-3-3. HEAD

HEAD 메서드는 정확히 GET처럼 동작하지만, 서버는 응답으로 헤더만을 돌려줍니다. 엔터티 본문은 반환되지 않습니다. 이는 클라이언트가 리소스를 가져올 필요 없이 헤다만을 조사할 수 있게 해줍니다. HEAD를 사용하면,

- 리소스를 가져오지 않고도 리소스가 무엇인가(타입이러거나)를 알아낼 수 있습니다.
- 응답 상태 코드를 통해, 개체가 존재하는지 알 수 있습니다.
- 헤더를 확인하여 리소스가 변경되었는지 확인할 수 있습니다.

서버 개발자들은 HEAD 메서드로 얻어지는 헤더가 정확히 GET 메서드로 얻어지는 헤더와 일치함을 보장해야 합니다. 또한 HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 합니다.

요청

```http
HEAD /seasonal/index-fall.html HTTP/1.1
Host: www.joes-hardware.com
Accept: *
```

응답

```http
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 617
```

### 3-3-4. PUT

GET 메서드가 서버로부터 문서를 읽어 들이는 것이라면,  PUT 메서드는 서버에 문서를 쓰는 작업을 수행합니다. 사용자가 PUT을 이용해 웹 페이지를 만들고 웹 서버에 직접 게시할 수 있도록 해줍니다.

PUT 메서드의 의미는, 서버가 요청 본문을 가지고 요청 URL 이름대로 새 문서를 만들거나 만약 이미 존재하고 있으면 본문을 사용해서 이를 교체하는 것입니다. PUT은 콘텐츠를 변경할 수 있게 해주기 때문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인할 것을 요구합니다. 

요청

```http
PUT /product-list.txt HTTP/1.1
Host: www.joes-hardware.com
Content-Type: text/plain
Content-Length: 34

Updated product list coming soon!
```

응답

```http
HTTP/1.1 201 Created
Location: http://www.joes-hardware.com/product-list.txt
Content-Type: text/plain
Content-Length: 34

http://www.joes-hardware.com/product-list.txt
```

### 3-3-5. POST

POST 메서드는 서버에 입력 데이터를 전송하기 위해 고안되었습니다. 실제로 HTML 폼을 지원하기 위해 흔히 사용됩니다. 폼에 담긴 데이터는 서버로 전송되고, 서버는 이를 모아서 필요로 하는 곳에 보냅니다.

요청

```http
POST /inventory-check.cgi HTTP/1.1
Host: www.joes-hardware.com
Content-Type: text/plain
Content-Length: 18

item=bandsaw 2647
```

응답

```http
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 18

The bamdsaw model 2647 is in stock!
```

### 3-3-6. TRACE

클라이언트가 요청을 할 때, 그 요청은 프락시, 방화벽, 게이트웨이 등등 다양한 애플리케이션을 통과할 수 있습니다. 이 애플리케이션들은 HTTP 요청을 수정할 수 있습니다. TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때까지의 상황을 알려줍니다.

TRACE 요청은 목적지 서버에서 '루프백' 진단을 시작합니다. 요청 전송 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답으로 되돌려줍니다. 클라이언트는 자신과 최종 서버 사이에 있는 모든 애플리케이션 요청/응답을 따라가면서 자신이 보낸 요청이 수정되거나 왜곡되었는지 만일 그렇다면 어떻게 변했는지 확인할 수 있습니다. 이렇게 TRACE 메서드는 주로 진단을 위해 사용됩니다.

TRACE는 진단을 위해 사용될 때는 괜찮지만, 그 대신 중간 애플리케이션이 여러 다른 종류의 요청들을 일관되게 다룬다고 가정하는 문제가 있습니다. 많은 애플리케이션은 메서드에 따라 다르게 동작합니다. 예를 들어, 프락시는 POST 요청을 바로 서버로 통과시키는 반면 GET 요청은 웹 캐시와 같은 다른 HTTP 애플리케이션으로 전송하기도 합니다. TRACE는 메서드를 구별하는 메커니즘을 따로 제공하지 않습니다. 어떻게 TRACE 요청을 처리할 지는 일반적으로 중간 애플리케이션이 결정을 내립니다. TRACE 요청에는 어떠한 엔터티도 보낼 수 없습니다. TRACE 응답 엔터티 본문에는 서바가 받은 요청이 그대로 들어있습니다.

클라이언트가 보낸 요청

```http
TRACE /product-list.txt HTTP/1.1
Accept: *
Host: www.joes-hardware.com
```

프락시가 보낸 요청

```http
TRACE /product-list.txt HTTP/1.1
Accept: *
Host: www.joes-hardware.com
Via: 1.1 proxy3.company.com
```

서버가 보낸 응답

```http
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 96

TRACE /product-list.txt HTTP/1.1
Accept: *
Host: www.joes-hardware.com
Via: 1.1 proxy3.company.com
```

프락시가 보낸 응답

```http
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 96
Via: 1.1 proxy3.company.com

TRACE /product-list.txt HTTP/1.1
Accept: *
Host: www.joes-hardware.com
Via: 1.1 proxy3.company.com
```

### 3-3-7. OPTIONS

OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어봅니다. 서버에 특정 리소스 관련 어떤 메서드가 지원되는지 물어볼 수 있습니다. (몇몇 서버는 특정 리소스에 대해 특정 동작만을 지원하기 때문입니다.) OPTIONS 메서드는 여러 리소스에 실제로 접근하지 않고도 어떻게 접근하는 것이 최선인지 클라이언트에 제공합니다.

요청

```http
OPTIONS * HTTP/1.1
Host: www.joes-hardware.com
Accept: *
```

응답

```http
HTTP/1.1 200 OK
Allow: GET, POST, PUT, OPTIONS
Context-Length: 0
```

### 3-3-8. DELETE

DELETE 메서드는 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청합니다. 그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못합니다. 왜냐하면 HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문입니다.

요청

```http
DELETE /product-list.txt HTTP/1.1
Host: www.joes-hardware.com
```

응답

```http
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 54

I have your delete request, will take time to process.
```

### 3-4. 상태코드

상태코드는 크게 5가지로 나뉘어집니다. 상태코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공합니다.

### 3-4-1. 100-199: 정보성 상태 코드

정보성 상태 코드는 HTTP/1.1에서 도입되었습니다. 새롭지만 이러한 복잡함을 감수할 만한 가치가 있는지에 대해서는 아직 논란이 되고 있습니다.

100 Continue는 HTTP 클라이언트에서 서버에 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하고 싶을 때, 그 확인 작업을 최적화하기 위한 의도로 도입되었습니다.

### 3-4-2. 200-299: 성공 상태 코드

클라이언트가 요청을 보내고 서버가 성공적으로 대응하였을 때 나타나는 코드입니다.

### 3-4-3. 300-399: 리다이렉션 상태 코드

리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대한 다른 위치를 사용하라고 말해주거나 그 리소스 내용 대신 다른 대안 응답을 제공합니다. 만약 리소스 위치가 바꼈다면, 클라이언트에게 리소스가 옮겨졌으며 어디서 찾을 수 있는지 알려주기 위해 리다이렉션 상태코드와 선택적으로 Location 헤더를 보낼 수 있습니다.

### 3-4-4. 400-499: 클라이언트 에러 상태 코드

클라이언트가 서버가 다룰 수 없는 요청을 보내는 경우가 있습니다. 잘못 구성된 요청 메시지 같은 것이 있을 수 있고, 이 중 가장 흔한 것은 존재하지 않은 URL에 대한 요청입니다. 웹 브라우징을 하다 보면 우리는 악명 높은 404 Not Found 에러를 만나는 경우가 있습니다. 바로 서버가 우리에게, 우리가 자신이 알 수 없는 리소스에 대한 요청을 했다고 알려주는 것입니다. 많은 클라이언트 에러는 브라우저에 의해 처리됩니다. 하지만 404를 포함한 몇몇 에러는 처리되지 않고 우리에게 전달됩니다.

### 3-4-5. 500-599: 서버 에러 상태 코드

때로는 클라이언트에서 올바른 요청을 보냈어도 서버에서 에러가 발생하는 경우가 있습니다. 클라이언트가 서버의 제한에 걸린 것일 수도 있고 혹은 게이트웨이 리소스와 같은 서버 보조 구성요소에서 발생한 에러인 경우도 있습니다. 프락시는 클라이언트의 입장에서 서버와 대화를 시도할 때, 자주 이러한 에러를 만나게 됩니다.

### 3-5. 헤더

헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용됩니다. 헤더에는 특정 메시지에만 사용할 수 있는 헤더와, 더 일반적인 목적으로 사용할 수 있는 헤더, 그리고 응답과 요청 메시지 양쪽 모두에서 정보를 제공하는 헤더가 있습니다. 헤더는 크게 다섯가지로 분류됩니다.

**일반 헤더**

일반 헤더는 클라이언트, 서버 양쪽 모두가 사용합니다. 예를 들어, Date 헤더는 서버, 클라이언트 가리지 않고 메시지가 만들어진 일시를 나타내기 위해 사용하는 일반 목적 헤더입니다.

```http
Date: Tue, 3 Oct 1974 02:16:00 GMT
```

**요청 헤더**

요청 메시지를 위한 헤더입니다. 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 정보들을 제공합니다. 예를 들어, 이 Accept 헤더는 서버에게 클라이언트가 자신의 요청에 대응하는 어떤 미디어 타입도 받아들임을 의미합니다.

```http
Accept: */*
```

**응답 헤더**

응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 가지고 있습니다. 예를 들어, 다음의 Server 헤더는 클라이언트에게 그가 Tiki-Hut 서버 1.0 버전과 대화하고 있음을 알려줍니다.

```http
Server: Tiki-Hut/1.0
```

**엔터티 헤더**

엔터티 헤더는 엔터티 본문에 대한 헤더를 의미합니다.예를 들어, 엔터티 헤더는 엔터티 본문에 들어있는 데이터의 타입이 무엇인지 말해줄 수 있습니다. 예를 들어, 다음 Content-Type 헤더는 애플리케이션에게 데이터가 iso-latin-1 문자집합으로 된 HTML 문서임을 알려줍니다.

```http
Content-Type: text/html; charset=iso-latin-1
```

**확장 헤더**

확장 헤더는 애플리케이션 개발자들에 의해 만들어졌지만 HTTP 명세에 포함되지 않은 비표준 헤더를 의미합니다. HTTP 프로그램은 확장 헤더들에 대해 그 의미를 모를지라도 용인하고 전달해야 할 필요가 있습니다.

### 3-5-1. 일반 헤더

| 헤더                      | 설명                                                         |
| ------------------------- | ------------------------------------------------------------ |
| Connection                | 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 해줍니다. |
| Date                      | 메시지가 언제 만들어졌는지에 대한 날짜와 시간을 제공합니다.  |
| MIME-Version              | 발송자가 사용한 MIME 버전을 알려줍니다.                      |
| Trailer chuncked transfer | 인코딩된 메시지 끝 부분에 위치한 헤더들의 목록을 나열합니다. |
| Transfer-Encoding         | 수신자에게 안전한 전송을 위해 어떤 인코딩이 적용되었는지 말해줍니다. |
| Upgrade                   | 발송자가 '업그레이드'하길 원하는 새 버전이나 프로토콜을 알려줍니다. |
| Via                       | 이 메시지가 어떤 중개자(프락시. 게이트 웨이))를 거쳐왔는지 보여줍니다. |

### 3-5-2. 요청 헤더

| 헤더       | 설명                                                  |
| ---------- | ----------------------------------------------------- |
| Client-IP  | 클라이언트가 실행된 컴퓨터 IP 주소를 제공합니다.      |
| From       | 클라이언트 사용자 메일 주소를 제공합니다.             |
| Host       | 요청의 대상이 되는 서버의 호스트 명과 포트를 줍니다.  |
| Referer    | 현재의 요청 URI가 들어있었던 문서의 URL을 제공합니다. |
| User-Agent | 요청을 보낸 애플리케이션 이름을 서버에게 말해줍니다.  |

**Accept 관련 헤더**

클라이언트는 Accept 관련 헤더들을 사용해 서버에게 자신의 선호와 능력을 알려줄 수 있습니다. 서버는 이 정보를 통해 무엇을 보낼 것인가에 대한 더 명확한 결정을 내릴 수 있습니다.

| 헤더            | 설명                                                  |
| --------------- | ----------------------------------------------------- |
| Accept          | 서버에게 서버가 보내도 되는 미디어 종류를 알려줍니다. |
| Accept-Charset  | 서버에게 서버가 보내도 되는 문자집합을 말해줍니다.    |
| Accept-Encoding | 서버에게 서버가 보내도 되는 인코딩을 말해줍니다.      |
| Accept-Language | 서버에게 서버가 보내도 되는 언어를 말해줍니다.        |

**조건부 요청 헤더**

클라이언트는 종종 자신의 요청에 몇몇 제약을 넣기도 합니다. 예를 들어, 클라이언트가 어떤 문서의 사본을 가지고 있는 상태라면, 클라이언트는 서버에게 그 문서를 요청할 때 자신의 것과 다른경우에만 전송해 달라고 요청하고 싶을 것입니다. 조건부 요청 헤더를 사용하면, 클라이언트는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있습니다.

| 헤더                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| Expect              | 클라이언트가 요청에 필요한 서버의 행동을 열거할 수 있게 해줍니다. |
| If-Modified-Since   | 주어진 날짜 이후에 리소스가 변경되지 않았다면 요청을 제한합니다. |
| If-Range            | 문서의 특정 범위에 대한 요청을 할 수 있게 해줍니다.          |
| If-Unmodified-Since | 주어진 날짜 이후에 리소스가 변경되었다면 요청을 제한합니다.  |
| Range               | 서버가 범위 요청을 지원한다면, 리소스에 대한 특정 범위를 요청합니다. |

**요청 보안 헤더**

HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 가지고 있습니다. 요청하는 클라이언트가 어느 정도의 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 더 안전하게 만들고자 하기 위함입니다.

| 헤더          | 요청                                                         |
| ------------- | ------------------------------------------------------------ |
| Authorization | 클라이언트가 서버에게 제공하는 인증 그 자체에 대한 정보를 담고 있습니다. |
| Cookie        | 클라이언트가 서버에게 토큰을 전달할 때 사용합니다.           |
| Cookie2       | 요청자가 지원하는 쿠키의 버전을 알려줄 때 사용합니다.        |

**프락시 요청 헤더**

인터넷에서 프락시가 점점 흔해지면서, 그들의 기능을 돕기 위한 몇몇 헤더들이 정의되어 왔습니다.

| 헤더                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| Max-Forwards        | 요청이 원 서버로 향하는 과정에서 다른 프락시나 게이트웨이로 전달될 수 있는 최대 횟수. TRACE 메서드와 함께 사용합니다. |
| Proxy-Authorization | Authorization과 같으나 프락시에서 인증할 때 사용합니다.      |
| Proxy-Connection    | Connection과 같으나 프락시에서 연결을 맺을 때 사용합니다.    |

### 3-5-3. 응답 헤더

응답 헤더는 클라이언트에게 부가적인 정보를 제공합니다.이 헤더들은 클라이언트가 응답을 잘 다루고 나중에 더 나은 요청을 할 수 있도록 도와줍니다.

| 헤더        | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| Age         | 응답이 얼마나 오래되었는지                                   |
| Public      | 서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록        |
| Retry-After | 현재 리소스가 사용 불가능한 상태 일때, 언제 가능해지는지 날짜 혹은 시각 |
| Server      | 서버 애플리케이션의 이름과 버전                              |
| Title       | HTML 문서에서 주어진 것과 같은 제목                          |
| Warning     | 사유 구절에 있는 것보다 더 자세한 경고 메시지                |

**협상 헤더**

서버에 독일어, 프랑스어로 번역된 HTML 문서가 있는 경우 처럼, 여러가지 표현이 가능한 상황이라면, HTTP/1.1은 서버와 클라이언트가 어떤 표현을 택할 것인가에 대한 협상을 할 수 있게 지원합니다.

| 헤더          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| Accept-Ranges | 서버가 받아들일 수 있는 자원 범위의 형태                     |
| Vary          | 서버가 확인해 보아야 하고 그렇기 때문에 응답에 영향을 줄 수 있는 헤더들의 목록 |

**응답 보안 헤더**

기본적인 인증 요구 헤더입니다.

| 헤더               | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| Proxy-Authenticate | 프락시에서 클라이언트로 보낸 인증 요구의 목록                |
| Set-Cookie         | 서버가 클라이언트를 인증할 수 있도록 클라이언트 측에서 토큰을 설정하기 위해 사용합니다. |
| Set-Cookie2        | Set-Cookie와 비슷한 RFC 2965에 정의된 쿠키                   |
| WWW-Authenticate   | 서버에서 클라이언트로 보낸 인증요구의 목록                   |

### 3-5-4. 엔터티 헤더

HTTP 메시지 엔터티에 대해 설명하는 헤더들은 많다. 요청과 응답 양쪽 모두 엔터티를 포함할 수 있기에, 이 헤더들은 양 타입의 메시지에 모두 나타날 수 있습니다.

| 헤더     | 설명                                                         |
| -------- | ------------------------------------------------------------ |
| Allow    | 이 엔터티에 대해 수행될 수 있는 요청 메서드들을 나열합니다.  |
| Location | 클라이언트에게 엔터티가 실제로 어디에 위치하고 있는지 말해줍니다. 수신자에게 리소스에 대한 (아마도 새로운) 위치(URL)를 알려줄 때 사용합니다. |

**콘텐츠 헤더**

콘텐츠 헤더는 엔터티의 콘텐츠에 대한 구체적인 정보를 제공합니다.

| 헤더             | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| Content-Base     | 본문에 사용된 상대 URL을 계산하기 위한 기저 URL              |
| Content-Encoding | 본문에 적용된 어떤 인코딩                                    |
| Content-Language | 본문을 이해하는데 가장 적절한 자연어                         |
| Content-Length   | 본문의 길이나 크기                                           |
| Content-Location | 리소스가 실제로 어디에 위치해 있는지                         |
| Content-Range    | 전체 리소스에서 이 엔터티가 해당하는 범위를 바이트 단위로 표현 |
| Content-Type     | 이 본문이 어떤 종류의 객체인지                               |

